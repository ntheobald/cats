#num9proj.py


# to solve for the pythagorean triple of 1000,  I will be using a^2+b^2=c^2
# c= a+b
# logically, a and b are likely not larger than 1000, I will start by creating a range from 1 to 1000 and set a and b equal to it
#only thing is that if a increases by 1, b must decrease by one, but always, a+b must equal c
import numpy as nu
import time
import threading
import queue
q = queue.Queue()
#to introduce multi-threading, I have to create multiple fuctions to run on different threads, It will require a complete redesign, and is below
def numberavailible():
    x=0
    y=0
    z=0
    print(x)
    while x<1000:
        print('################################################################################################')
        print('num x here:')
        print(x)
        x=x+1
        y=0
        while y<1000:
            print('########################')
            print('num y here:')
            print(y)
            y=y+1
            
            print('')
            print('current runtime is:'+str(x))
            while z<1000:
                print('################################################')
                print('z num here:')
                print(z)
                z=z+1

            if z**2==x**+y**2:
                print('possible solution')
                if z+x+y==1000:
                    print('here is x: '+str(x))
                    print('here is y: '+str(y))
                    print('here is z: '+str(z))
                    print('here is the answer')
            
            # if add==1000:
            #     solist=[]
            #     print('solution found?')
            #     print('here is x')
            #     print(x)
            #     print(' ')
            #     print('here is y')
            #     print(y)
            #     solist.append(x)
            #     solist.append(y)
            #     print('solist: '+str(solist))
            #     print('')
            #     # if the addition of the squares equals a numer which can be rooted and added to a and b to get to 100, it will be correct
            #     testpowerofx=x**2
            #     testpowerofy=y**2
            #     added=nu.add(testpowerofx,testpowerofy)
            #     print('here is testpowerofx: '+str(testpowerofx))
            #     print('here is testpowerofy: '+str(testpowerofy))
            #     print('here is their sum: '+str(added))
                
            #     rootnum=x**2+y**2
            #     print('here is rootnum: '+str(rootnum))
            #     print('rootnum inputs are: '+'x: '+str(x)+' y:'+str(y))
            #     testexp=nu.sqrt(rootnum)
            #     print('squareroot of the rootnum is: '+str(testexp))
            #     thousandmb=testexp+rootnum
            #     print('here is mb thousand: '+str(thousandmb))
            #     quit()

            #     if thousandmb== 1000:
            #         print('success!!!!')
            #         print('here is x')
            #         print(x)
            #         print('')
            #         print('here is y')
            #         print(y)
            #         print('')
            #         print('here is the square (before ^2)')
            #         print(routnum)
            #         quit()
# numberavailible()


# here I will write out multiple fuctions to be executed at once
#the guide I am learnign from is availible at this URL https://www.youtube.com/watch?reload=9&v=PJ4t2U15ACo&ab_channel=codebasics
# the syntax to perform an operation is below 
#t1=threading.Thread(target=*enter function name*, args=(*enter arguments here*))
#t1.start() this will initiate the calculation
#t2.start()
#t1.join() this will in one way or another, return the results from the operation and wait until the other thread has finished, once they 
#have finished, they will share information, 
#t2.join()



# def test_one():
        
#         x=999999
#         while x>0:
#             # print('################################################################################################')
#             # print('num x here:')
#             print(x)
#             x=x-1

# def test_two():
#         y=0
#         while y<1000000:
#             print(y)
#             y=y+1

# t1=threading.Thread(target=test_one, args=())
# t2=threading.Thread(target=test_two, args=())
# t1.start() 
# t2.start()
# t1.join()
# t2.join()
# t=time.time()
# print('took this long: '+str(t))
# In total, if I calculate every possible combination, I will conduct 1 around 1 billion processes 
#if I can complete one set of processes, say 1,000 combinations of x and y, after the first 1,000, i can export them to a different core
#i can work on the first set of x(range(1-1000))^2+y(1)^2, while i calculate the combinations between x(range1-1000)and y(2)

#reffer to https://nitratine.net/blog/post/python-threading-basics/ for more info on threading and passing args
#here is how you implement queues to share variables across threads (returning does not work) https://stackoverflow.com/questions/15461413/how-to-share-a-variable-between-2-threads 
# https://docs.python.org/3/library/asyncio-queue.html - queue module in python
#https://www.geeksforgeeks.org/python-communicating-between-threads-set-1/ more info on how to share


def t1_step1():
        T1x=0
        while T1x<20:
            T1x=T1x+1
            T1y=0 
            while T1y<50:
                T1y=T1y+1
                print('t1x')
                print(T1x)
                print(T1y)
                q.put(T1x)
                # t1.join()
                # T1x=q.get()
                # T1y=q.get()
                




def t5_step2():
    print('evaluated#####################################################')
    t1.join()
    T1x=q.get(T1x)
    # q.empty()
    print('second process: '+str(T1x))
    # t5.join()



# t2=threading.Thread(target=t2_step1, args=())
# t3=threading.Thread(target=t3_step1, args=())
# t4=threading.Thread(target=t4_step1, args=())

# T1x=0

t1=threading.Thread(target=t1_step1, args=())
t1.start()
t1.join()
t5=threading.Thread(target=t5_step2, args=()) 
t5.start()

# t5.join()


# t2.start()
# t3.start()
# t4.start()



# t2.join()
# t3.join()
# t4.join()



# def t2_step1():
#         T2x=251
#         while T2x<500:
#             T2x=T2x+1
#             T2y=0
#             while T2y<1000:
#                 T2y=T2y+1
#                 print('t2x')
#                 print(T2x)
#                 print(T2y)


# def t3_step1():
#         T3x=501
#         while T3x<750:
#             T3x=T3x+1
#             T3y=0
#             while T3y<1000:
#                 T3y=T3y+1
#                 print('t3x')
#                 print(T3x)
#                 print(T3y)

# def t4_step1():
#         T4x=751
#         while T4x<1000:
#             T4x=T4x+1
#             T4y=0
#             while T4y<1000:
#                 T4y=T4y+1
#                 print('t4x')
#                 print(T4x)
#                 print(T4y)


#the code outline was sourced by:https://www.geeksforgeeks.org/python-communicating-between-threads-set-1/ 

from queue import Queue 
from threading import Thread 
  
def producer(out_q): 
    T1x=0
    while T1x<100: 
        T1y=0      
        while T1y<100:
            T1y=T1y+1
            # data=T1y
            entrence=[]
            entrence.append(T1x)
            entrence.append(T1y)
            out_q.put(entrence)
            # out_q.put(T1y) 
        T1x=T1x+1
        # print('here is T1x: '+str(T1x))
        # out_q.put(T1x)
        # c='see!?'
        # out_d.put(c)
        # return False
    reg=False
    out_q.put(reg)
    quit()
          
          
# A thread that consumes data 
def processor(in_q,out_r): 
    while True: 
        # Get some data 
        # Process the data 
        randname = in_q.get() 
        # cat=in_d.get()

        if randname==False:
            quit()
        
        print('###################### here is my data:'+str(randname))
        ls=15
        out_r.put(ls)
        # print('see this?:'+str(cat))
        
        # T1x=in_q.get()
        # print('################################################################## here is my data:'+str(T1x))
        
def sqr(in_r):
    while True:
        ls=in_r.get()
        print('here is my ls, it will be square rooted!: '+str(ls))

          
# Create the shared queue and launch both threads 
q = Queue() 
r= Queue()

t1 = Thread(target = producer, args =(q,)) 
t2 = Thread(target = processor, args =(q,r))
t3 = Thread(target = sqr, args =(r,))

t1.start() 
t2.start() 
t3.start()

